- This is a really important part of Swift that you should pay a lot of attention to. Actor were introduced in Swift 5.5 with the premise of solving data races exceptions. What is a [Data race](https://www.avanderlee.com/swift/thread-sanitizer-data-races/#what-are-data-races), you might ask? Well, think of what you were currently doing up until now. Let's say, for example, you'd have a function that wanted to access the profile data from a user to display it on profile, but on the main homepage of your app there is another function that takes the user's name and displays it in the topbar, with both of them accessing data from the same place. Let's say that the user changes the name of his profile. What might happen is that the topbar will fetch the user's name while at the same time the profile will overwrite the user name in our profile data. This can lead to unpredictable behaviour, crashes, memory corruption or other things. So, Actors were introduced with the aim of protecting their state from data races. Think of them as some kind of Gardians of the Galaxy, but for data types in Swift. Actors are defined using the `actor` keyword, and it acts just like a Class, but, they DO NOT support inheritance. But the biggest difference is that they isolate access to data. They prevent data races by creating synchronized access to its isolated data, with the Swift compiler taking care of how the data is actually protected. Swiftful Thinking provides a great video of understanding the differences between Struct, Classes, and Actors, but it's really long. It's worth a watch, because his explanation is very thorough and entertaining.
	- [Swift: Struct vs Class vs Actor, Value as Reference Types, Stack vs Heap](https://youtu.be/-JLenSTKEcA?si=WCtDkm-gbt6I3Tou)
	- [How to use Actors in Swift](https://youtu.be/5LKbL-I-CYY?si=e8NBniS8r0Dgj6IE)
	- [How to use Actors and non-isolated in Swift](https://youtu.be/UUdi137FySk?si=-zJ7G9I57A1RO2uy)